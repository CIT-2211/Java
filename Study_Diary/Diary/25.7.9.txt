2025/7/9 	多云转晴	很热，晚上的凉风吹的很舒服

上午学习了nodepad++的宏操作，果然对于老机子而言版本越老越香！基本上宏没什么用，类似于虚拟机的快照功能。可以进行代码的录制，保存后就可以快速部署代码了，就像录像带倒带那样。但是，它这个功能只支持底版本，高版本已经被插件取缔，也算时代发展吧！
随后重新系统学习了内存机制，结合着deepseek自己亲自动手画了一遍内存结构图，基本上掌握了基本内存机制。
##注意点:
	1、栈帧：方法是先进，后出，最先缓存args对象，调用main方法（局部方法）。
	   方法和对象是开辟在不同的栈空间的。
	   方法的分类：实例方法、静态方法、构造方法（类的方法，初始化对象）
	2、创建对象:new ---> 堆中生成这个类的一个对象（地址） ---> 栈帧main中生成该对象引用变量 ---> 堆对方法区进行调用
	3、方法区现在也叫原空间（仅JDK>8时支持）
	4、Java参数传值机制：
		（int）基本数据类型：传递值的副本，副本改变不会影响原件。
		(对象数组)应用类型：副本（对象地址），副本改变 --> 对象地址改变（原参数指向的对象发生改变）
	5、构造方法 -----> 初始化对象

下午学了简单的垃圾处理和this的本质
##垃圾处理：目标：堆中变量、对象  --->  没人调用  --> 清除
常见的两种算法：
1、引用计数法：	引用目标 ---> 计数+1
		禁用失效 ---> 计数-1
		技术为零 ---> 清除目标
优点：算法简单	
缺点：循环引用对象（堆内相互引用）难以识别
2、根搜索法（引用可达法）：
		根节点（GC ROOT）出发找到相应的节点，剩余节点为无用节点----清除
3、其他方法

##通用的分代回收机制：（根本原理-----生命周期不同）
堆内模型：年轻区、老年区、永久区
划分：
年轻区：Eden区 ---> 未被回收过的新方法	|| 空间小，小垃圾桶
	survivor区：1区，2区每次进行清理都会两个区的对象会进行交换（储存交换不超过15次的对象）
老年区：存放超过15次的对象
永久区：存放原空间、静态方法、对象、常量池等

Minor GC （轻量级）:  当年轻区的Eden or survivor满了自动清理，剩下的复制到survivor里面，两区交换
Major GC （中量级）:  清理老年区
Full GC  （重量级）:   垃圾车，清理所有三个区域
Full GC可能调用：	1、老年区满了
			2、永久区满了
			3、程序员调用System.gc();向Full GC申请
 			4、上次GC后Heap各域分配策略动态变化

##内存泄漏操作：内存没有存放，内存浪费 ---> 速度变慢、系统崩溃
例如：	1、创建大量无用对象	2、各种链接对象未关闭
 	3、静态集合类大量使用	4、监听器使用不当
Other：
1、程序员无权调用Full GC 但可以用System.gc()来通知Full GC
2、Object对象中finalize方法可以释放对象、资源，但请少用
3、嵌入式、JVM优化就是和这些有关

##this本质：当前对象地址（隐式引用变量 ---> 生成this栈帧），不可用于static方法、类
作用：	1、区别同名变量			1、解决变量名冲突问题（构造方法要放在最前面-----初始化变量）
	2、显示传递当前对象		2、返回当前值
	3、链式调用（大多数可以隐藏）	3、内部访问外部类
	4、内部类中访问外部对象





		   